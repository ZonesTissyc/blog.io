[{"content":"变量名\r变量 变量名格式 示例 顶点着色器源码 vertexShaderSource_name vertexShaderSource_body ","date":"2025-12-18T22:16:40+08:00","permalink":"https://blog.ztcdream.com/p/opengl%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/","title":"OPENGL编程规范"},{"content":"观察变换\r观察变换作用是决定摄像机从哪看，看向哪里，以及怎么看，也就是模拟一个眼睛在三维坐标里的位置和朝向。\n实现：使用 观察矩阵 ，把世界中的所有物体的坐标，从世界坐标系变换到局部坐标系。\n代码实现\r实践中无需手动求出观察矩阵，只需指定3个重要的参数：\n摄像机位置\ncameraPos:摄像机在世界坐标系里的位置\n观察目标点\ncameraTarget:摄像机看向哪个点\n上方向\nupVector:摄像机头顶的方向\n将3个参数传入 glm::lookAt() 函数，即求解出观察矩阵。\n示例：\n1 2 3 4 5 6 glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f); // 摄像机在世界坐标系的位置：Z轴正方向3单位 glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f); // 摄像机看向原点 glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f); // 摄像机的上方向是世界Y轴正方向 // 观察矩阵（View Matrix）的计算 glm::mat4 view = glm::lookAt(cameraPos, cameraTarget, cameraUp); OpenGL 的历史和设计遵循 Y 轴向上的约定。\n自由视角\r之前生成观察矩阵使用的三个参数中，决定看向哪的参数是一个点。这就导致移动摄像机的位置后，要保持“朝前看”的效果，就要同时更新目标点。\n因此可以将第二个参数 cameraTarget 改成 cameraFront ,原生成矩阵的参数更改为：\n1 view = lookAt (camearaPos, cameraPos + cameraFront, cameraUp) 这样改变摄像机位置后，视角仍然朝前。\n","date":"2025-12-16T21:18:27+08:00","permalink":"https://blog.ztcdream.com/p/%E8%A7%82%E5%AF%9F%E5%8F%98%E6%8D%A2/","title":"观察变换"},{"content":"头文件\ropengl一般用到的头文件:\n1 2 3 4 5 6 7 #include \u0026lt;glm/glm.hpp\u0026gt; #include \u0026lt;glm/gtc/matrix_transform.hpp\u0026gt; #include \u0026lt;glm/gtc/type_ptr.hpp\u0026gt; #include \u0026lt;glad/glad.h\u0026gt; #include \u0026lt;GLFW/glfw3.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; 其中，glm 为转为opengl设计的矩阵运算库, glad 用于加载函数指针, GLFW 用于获得窗口。\n::: note\n注意：头文件的引用的先后顺序是很讲究的，glad 必须 先于 glfw 导入！\n:::\n工程上不使用 using namespace std; 命名空间，输出日志使用 std::cout\n创建窗口\r需要头文件 glfw3.h\n1 #include \u0026lt;GLFW/glfw3.h\u0026gt; 初始化 glfw\nglfwInit()：初始化，返回0表示正常\n创建窗口\nglfwCreateWindow()：创建窗口，接收窗口的长和宽，返回指向窗口对象的 指针。\n1 GLFWwindow *window = glfwCreateWindow(1280, 720, \u0026#34;GED\u0026#34;, nullptr, nullptr); 设置窗口位置\nglfwSetWindowPos()：设置窗口出现在电脑屏幕的何处，视具体电脑而异。\n1 glfwSetWindowPos(window, 1000, 150) 这一步最重要的是获得窗口对象的指针。之后要设置和操作这个窗口，就要传入指针。\n初始化OPENGL\rOPENGL的驱动一般包含在各个显卡的驱动中，不用额外下载。除非你电脑刚买或者完全不联网不玩游戏\n需要一个库来获得OPENGL的函数指针，常用glad。\n包含头文件 glad.h\n1 #include \u0026lt;glad/glad.h\u0026gt; 确定opengl版本\n这一步是对整个glfw操作，所以要在初始化glfw之后，创建window之前。\nglfwWindowHint:多重载函数，接收不同的命令设置不同的参数。\n1 2 3 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // opengl大版本 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // opengl小版本 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); 与window关联\nglfwMakeContextCurrent：将设置的OPENGL信息与window关联。\n1 glfwMakeContextCurrent(window); 使用glad加载函数指针\ngladLoadGLLoader()：返回值应为0。\n1 gladLoadGLLoader((GLADloadproc)glfwGetProcAddress) 颜色\rOPENGL有四个颜色通道：\nRed：红 Green：绿 Blue：蓝 Alpha：透明度 传值可以用RGB，取值范围： $[0,255]$ ；也可以是将其归一化后的浮点数，取整范围 $[0.0,1.0]$\n旧版本一些函数不支持整数类型，因此必须使用归一化后的浮点数。可自定义归一化函数，方便传入RGB常规色值。\n设置window背景颜色\nglClearColor()：接收red、green、blue、alpha四个值。\n1 glClearColor(1.0f, 0.5f, 0.7f, 0.2f); 让设置生效\nglClear()：从颜色缓存里加载。\n1 glClear(GL_COLOR_BUFFER_BIT); 上面的设置背景实际上不会生效，因为opengl使用双缓冲方案。\n交换双缓冲\ropengl使用双缓冲方案，在每生成下一帧时实际操作的是后缓冲区，要把后缓冲区交换成当前缓冲区。\n交换缓冲的函数：\n1 glfwSwapBuffers(window); 顶点\r把所有顶点的三维坐标放在一个数组里。\n1 2 3 4 5 float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f }; 上面的每个顶点只包含了 xyz的值，实际上可以是 “空间坐标+纹理坐标”，“空间坐标加法线”等。 数组是一维的，每个坐标都在 $[-1.0, 1.0]$。\nVBO \u0026amp; VAO\r一个常见的说法来理解 VBO/VAO是：VBO是顶点数据的快递箱，负责打包数据，运送至显存；VAO则是附在上面的说明书，告诉显卡如何解包这些顶点。\nVBO \u0026amp; VAO 都是opengl对象，它们构建了cpu与gpu沟通的桥梁。 申请 VBO 和 VAO ： 1 2 3 unsigned int VBO, VAO; glGenVertexArrays(1, \u0026amp;VAO); glGenBuffers(1, \u0026amp;VBO); 绑定 VAO\nVAO 和 VBO 应当是捆绑在一起的。opengl是一个状态机，当我们执行某一条命令后，之后的操作默认与之绑定，直到解绑为止。\n1 glBindVertexArray(VAO); //绑定开始 执行这条命令后，后面的操作与VAO绑定了，即便不是，也应当绑定。\n把顶点数组复制到缓冲中 1 2 glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 设置顶点属性指针 告诉 OpenGL 如何解析这些数据。 参数：属性位置(0), 组成元素个数(3), 类型, 是否标准化, 步长, 偏移量\n1 2 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE,5 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); 解绑 glBindBuffer(GL_ARRAY_BUFFER, 0);\nglBindVertexArray(0); // 绑定结束 glBindVertexArray(0) 重新设置为0， 这一轮的VAO绑定结束了。\n顶点着色器\r着色器语言GLSL:\n1 2 3 4 5 6 7 #version 330 core layout (location = 0) in vec3 aPos; void main() { gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0); } 创建着色器对象：\n1 2 unsigned int vertexShader; vertexShader = glCreateShader(GL_VERTEX_SHADER); 把源码字符串附加给着色器对象：\n1 2 glShaderSource(vertexShader, 1, \u0026amp;vertexShaderSource, NULL); glCompileShader(vertexShader); 检测是否编译成功：\n1 2 3 4 5 6 7 8 9 int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, \u0026amp;success); if(!success) { glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout \u0026lt;\u0026lt; \u0026#34;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\u0026#34; \u0026lt;\u0026lt; infoLog \u0026lt;\u0026lt; std::endl; } 片段着色器\r片段着色器决定了像素最终显示的颜色。\n抗锯齿发生在这一阶段。\nGLSL:\n1 2 3 4 5 6 7 #version 330 core out vec4 FragColor; void main() { FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f); } 1 2 3 4 unsigned int fragmentShader; fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, \u0026amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); 着色器程序\r创建了上面两个着色器对象之后，还需要着色器程序对象组装多个着色器对象。\n创建着色器程序对象：\n1 2 unsigned int shaderProgram; shaderProgram = glCreateProgram(); 将之前的着色器对象附加到程序对象，然后链接：\n1 2 3 glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); 检查：\n1 2 3 4 5 glGetProgramiv(shaderProgram, GL_LINK_STATUS, \u0026amp;success); if(!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); ... } 激活程序对象：\n1 glUseProgram(shaderProgram); 删除着色器对象：\n1 2 glDeleteShader(vertexShader); glDeleteShader(fragmentShader); ","date":"2025-12-05T10:00:31+08:00","permalink":"https://blog.ztcdream.com/p/opengl%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B/","title":"opengl的大致流程"},{"content":" 递归本质上做的事\r递归遍历其实就做了三件事：\n访问当前节点（打印或处理数据）； 递归左子树； 递归右子树。 递归函数靠系统调用栈来记住“走到哪一步、该返回哪里”。 而非递归遍历，就是自己用栈（Stack）来模拟系统调用栈。\n非递归（模拟栈）的基本逻辑\r一个栈记录“接下来要访问的节点”。\n入栈（push）：表示“以后还要回来访问这个节点”； 出栈（pop）：表示“当前节点访问完成”； 栈顶代表当前递归层正在处理的节点。 三种遍历的思维区别\r遍历顺序 操作顺序（递归形式） 非递归实现的核心思路 前序遍历 根 → 左 → 右 出栈时访问 → 先压右再压左 中序遍历 左 → 根 → 右 一直向左入栈 → 遇空回退并访问，再右转 后序遍历 左 → 右 → 根 两次入栈 or 记录上次访问的节点 非递归遍历的具体思路\r1. 前序遍历（Preorder：根→左→右）\r思路：\r根节点先访问； 用栈保存节点； 先压右子树，再压左子树，这样出栈顺序正好是“左→右”。 步骤：\r根节点入栈；\n当栈不空：\n弹出栈顶并访问； 若有右子树 → 压入； 若有左子树 → 压入。 1 2 3 4 5 6 7 8 栈操作顺序： push(A) pop A → print(A) push(C) push(B) pop B → print(B) ... C++实现（简洁版）\r1 2 3 4 5 6 7 8 9 10 11 void preorder(Tree root) { if (!root) return; stack\u0026lt;Tree\u0026gt; s; s.push(root); while (!s.empty()) { Tree node = s.top(); s.pop(); cout \u0026lt;\u0026lt; node-\u0026gt;data \u0026lt;\u0026lt; \u0026#39; \u0026#39;; if (node-\u0026gt;RChild) s.push(node-\u0026gt;RChild); if (node-\u0026gt;LChild) s.push(node-\u0026gt;LChild); } } 2. 中序遍历（Inorder：左→根→右）\r思路：\r一直往左下走，把沿途节点入栈； 遇到空时，弹出一个节点访问； 再转向它的右子树，继续。 步骤：\r初始化指针 p = root；\n当 p 不空时入栈并左移；\n若 p 空：\n弹出栈顶并访问； 再右移； 重复直到栈空且 p 为空。\nC++实现\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void inorder(Tree root) { stack\u0026lt;Tree\u0026gt; s; Tree p = root; while (p || !s.empty()) { if (p) { s.push(p); p = p-\u0026gt;LChild; } else { p = s.top(); s.pop(); cout \u0026lt;\u0026lt; p-\u0026gt;data \u0026lt;\u0026lt; \u0026#39; \u0026#39;; p = p-\u0026gt;RChild; } } } 3. 后序遍历（Postorder：左→右→根）\r思路：\r后序遍历最麻烦，因为根在最后访问。 可以用两种常见思路：\n方法 1：两个栈（简单好记）\r栈1 用来正向遍历； 栈2 存储访问顺序； 最后输出栈2。 代码：\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void postorder(Tree root) { if (!root) return; stack\u0026lt;Tree\u0026gt; s1, s2; s1.push(root); while (!s1.empty()) { Tree node = s1.top(); s1.pop(); s2.push(node); if (node-\u0026gt;LChild) s1.push(node-\u0026gt;LChild); if (node-\u0026gt;RChild) s1.push(node-\u0026gt;RChild); } while (!s2.empty()) { cout \u0026lt;\u0026lt; s2.top()-\u0026gt;data \u0026lt;\u0026lt; \u0026#39; \u0026#39;; s2.pop(); } } 方法 2：一个栈 + 标记上次访问节点\r稍复杂，但节省空间：\n用 lastVisited 记录上次访问的节点； 如果右子树访问过或不存在，就访问当前节点。 记忆口诀总结\r遍历类型 思路口诀 前序遍历 “根先打印，右先压” 中序遍历 “一路左压，遇空弹栈，右转继续” 后序遍历 “根最后，双栈或标记法” 对比总结\r假设二叉树：\n1 2 3 4 5 A / \\ B C / \\ D E 遍历方式 输出结果 特点 前序 A B D E C 根先访问 中序 D B E A C 根在中间 后序 D E B C A 根最后访问 ","date":"2025-11-09T19:47:58+08:00","permalink":"https://blog.ztcdream.com/p/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E7%9C%81%E6%B5%81%E7%89%88/","title":"二叉树的遍历-省流版"},{"content":"题目\r某单位需要加工制作 100 套钢架，每套用长为 2.9m、2.1m 和 1m 的圆钢各一根。已知原料长 6.9m。\n（1）如何下料，使用的原材料最省。\n（2）若下料方式不超过 3 种，应如何下料，使用的原材料最省。\n分析\r题目隐含的条件是：每套中3个长度的钢管只能从比它更长的钢管切割而来，不能通过拼接其他小钢管合成。这意味着不同的下料切料方式，会产生不同数量的边角料，消耗不同的原料数。题目要求的就是让消耗的原料数最小。\n选取决策变量\r设3种钢管为 $A,B,C$ 号，长度分别为:\n$a=2.9,b=2.1,c=1.0$\n$a+b+c=6.0 \u0026lt;6.9$\n对于一根原料，它可以：\n1.不切割，获得长$6.9$的钢管\n2.切割一次，获得下面几种钢管\n(1) $2.9,4.0$\n(2) $2.1,4.8$\n(3) $1.0,5.9$\n3.切割两次\n(1) $2.9,2.9,1.1$\n(2) $2.9,2.1,1.9$\n(2) $$\n","date":"2025-11-04T22:39:10+08:00","permalink":"https://blog.ztcdream.com/p/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%A2%98/","title":"整数线性规划题"},{"content":"题目描述\r来自LeetCode第387题：字符串中的第一个唯一字符\n给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。 s只包含小写字母。\n图片：\n分析\r整体思路是遍历每一个字符，统计每个字符出现的次数，然后再遍历一遍字符串，找到第一个出现次数为1的字符。\n因此我们需要一个数组，用来：统计26个字母出现的次数。 第二次遍历的时候，从左到右查看每个字符是否只出现了一次。\n按照这个逻辑，这个题天然地适合用哈希表来做。每个字符的ASCII码值可以作为哈希表的索引，出现的次数作为值。 那么哈希生成函数就是：\n1 2 3 hash(char c) { return \u0026#39;c\u0026#39; - \u0026#39;a\u0026#39;; } 这时候，就可以用一个长度为26的数组来模拟哈希表。\n代码实现\r1 2 3 4 5 6 7 8 9 10 11 12 13 int firstUniqChar(char* s) { int times[26]; int len = strlen(s); for (int i=0;i\u0026lt;len;i++){ times[s[i]-\u0026#39;a\u0026#39;]++; } for(int i=0;i\u0026lt;strlen(s);i++){ if (times[s[i]-\u0026#39;a\u0026#39;]==1){ return i; } } return -1; } 问题延申\r原题是非常简单的，只要求第一次的索引，所以代码也无需优化，第二次遍历原字符串即可。 但是如果题目变种一下，要求返回所有只出现一次的字符呢？ 注意，这里改成了只出现的第一个的字符，而不是它的索引。\n新的问题用原来的逻辑也是可行的，但是效率不高。 因为第二次遍历原字符串时，可能会多次查找同一个字符的出现次数。 假设原字符串很大，那么第二次遍历的复杂度与第一次相当。\n那么第二次遍历，如何如何防止对一个字符多次查表呢？ 因为第一次遍历是从左到右（当然也可以从右到左），第二次遍历也是从左到右，第一次遍历的字母种类，第二次也要查一次。 那么我们可以用一个队列来存储第一次遍历时，出现过的字母。 第二次遍历时，无需遍历原字符串s，而是遍历队列中的字母。\n代码实现\r无队列版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int firstUniqChar(char* s) { int times[26]; int len = strlen(s); for (int i=0;i\u0026lt;len;i++){ times[s[i]-\u0026#39;a\u0026#39;]++; } for(int i=0;i\u0026lt;strlen(s);i++){ if (times[s[i]-\u0026#39;a\u0026#39;]==1){ return i; } } return -1; } 加入队列版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int firstUniqChar(char* s) { int times[26]; int queue[26]; int last = -1; // 队列尾指针 int len = strlen(s); for (int i=0;i\u0026lt;len;i++){ times[s[i]-\u0026#39;a\u0026#39;]++; if (times[s[i]-\u0026#39;a\u0026#39;]==1){ queue[++last] = s[i]-\u0026#39;a\u0026#39;; // 入队 } } for(int i=0;i\u0026lt;=last;i++){ if (times[queue[i]]==1){ return queue[i]+\u0026#39;a\u0026#39;; // 返回字符 } } return -1; } 复杂度分析\r原题的时间复杂度是O(n)，空间复杂度是O(1)。\n延申题的时间复杂度也是O(n)，空间复杂度是O(1)。\n不过，延申题使用队列后，第二次遍历的次数变少了。 以后遇到要两次遍历，前后的顺序相同时，为了避免重复，可以考虑用队列。 毕竟，队列是先进先出。\n","date":"2025-10-04T18:35:36+08:00","permalink":"https://blog.ztcdream.com/p/%E6%89%BE%E5%87%BA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/","title":"找出唯一字符"},{"content":"下面是用 node.js 搭建一个简单的网页服务，并构建成 Docker 镜像，并运行容器，使外部能访问这个网页。\n简单写个网页\r首先安装一下 npm：\n1 sudo apt install npm 初始化 npm 项目：\n1 npm init -y npm 安装 express 框架：\n1 npm install express 简单写一个 js 文件:\n1 2 3 4 5 6 7 8 9 const express = require(\u0026#34;express\u0026#34;); const app = express(); const PORT = 3000; app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;\u0026lt;p\u0026gt;智能感知——服务调度\u0026lt;/p\u0026gt;\u0026#34;); }); app.listen(PORT,() =\u0026gt; console.log(\u0026#34;端口号3000走起\u0026#34;)); 上面会在 3000 端口运行一个 html 服务。\n编辑Dockerfile\rnano Dockerfile\n写入：\n1 2 3 4 5 6 7 FROM node:18-alpine3.15 WORKDIR /ztc COPY package.json . RUN npm install COPY . . EXPOSE 3000 CMD [\u0026#34;node\u0026#34;,\u0026#34;app.js\u0026#34;] 配置忽略文件\r这个文件同 git 的 .gitignore ，可以在构建时忽略掉文件及文件夹。\nnano .dockerignore\n写入:\n1 2 3 node_modules Dockerfile .dockerignore 构建镜像\r把配置文件写好，就可以构建镜像了：\n1 docker build . 初次构建的时候是比较慢的。\n查看镜像：\n1 docker images 新创建的镜像还没有名字，所以显示为 \u0026lt;none\u0026gt;。\n可以为镜像添加名字：\n1 docker tag c5e zonestissyc/nodejs:v1.0 再看一下，发现改名成功了：\n运行容器\r1 docker run -d -p 3000:3000 --name hello-container zonestissyc/nodejs:v1.0 -d : 后台运行 -p 3000:3000: 端口转发，宿主机端口 $:$ 容器端口 --name hello-container : 给容器起个名 在浏览器访问一下：\n服务可以在外部访问了！！！\n文件同步\r为了实现镜像内文件的实时更新，需要在创建容器前加入 -v 选项，后跟 主机绝对路径:容器绝对路径\n1 docker -d -v /.../hello/:/ztc -p 3000:3000 hello-container 文件同步是双向的，容器内文件的改变，主机也会改变。\n如果想让主机只读，即容器改变后主机不变，可在 .../ztc 后加ro\n1 docker -d -v /.../hello/:/ztc:ro -p 3000:3000 hello-container 第二个 -v 可以设置不想同步的文件夹， 如 -v /ztc/node_modules。\n容器删除\r删除时最好对应把 volume 删除掉。\n1 docker rm -fv hello-container ","date":"2025-05-18T16:07:17+08:00","permalink":"https://blog.ztcdream.com/p/docker%E5%AE%9E%E6%88%98%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/","title":"Docker实战：构建镜像"},{"content":"运行hello,world\rDocker要简单地运行 Hello,world!，在部署完Docker后，可以直接执行\n1 docker run ubuntu:15.10 /bin/echo \u0026#34;Hello world\u0026#34; run 表示要运行容器，后面跟的 ubuntu:15.10 是镜像，本地不存在将从 Docker Hub 中拉取。 /bin/echo \u0026quot;Hello world\u0026quot; 是启动镜像后执行的命令。\n直接 dorcker run 后，不加其他参数，执行完 shell 命令后容器就退出了。\n这一点可以在 Protainer 中验证：\n后台运行\r想让容器后台运行，要在启动时加上 -d 参数。这样，容器的标准输出就不会出现在主Shell上。\ndocker run -d ubuntu:15.10 /bin/sh -c \u0026ldquo;while true; do echo hello world; sleep 1; done\u0026rdquo;\n这一次并没有输出 hello world，而是返回了一长串数字，这是 容器ID 。\n查询docker后台:\n1 docker ps 可以看到刚才创建的 ubuntu 容器还在运行。\n查看标准输出：\n1 docker logs fa9878 可以看到容器所有的标准输出。\n停止容器：\n1 docker stop fa9878 从面板中可以看到容器退出运行了：\n参考文献\r菜鸟教程：Docker Hello,world\n","date":"2025-05-18T14:46:10+08:00","permalink":"https://blog.ztcdream.com/p/docker%E5%AE%9E%E6%88%98%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/","title":"Docker实战：运行一个容器"},{"content":"安装iso镜像\r镜像可在 debian.org 上下载。\n中国大陆可用的镜像站：\n中国大陆: 兰州大学debian镜像站\n中国大陆: 网易debian镜像站\n一般选 iso-dvd 下的 iso 镜像。\n下面均以 debian 12 为例。\n分配磁盘：至少两个分区（建议），一个 efi 分区（Fat32），选作 保留的boot引导分区。另外一个ext4分区，用作系统根目录。\n不要选择使用网络镜像。软件选择那里不勾选桌面，勾选ssh服务端（建议）。\n安装完成后重启即可。\napt换源\r切换到root用户，执行nano /etc/apt/sources.list。\n换成清华源（北京市）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware # deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware 或者是中科大源（安徽省）：\n1 2 3 4 5 6 7 8 9 # 默认注释了源码仓库，如有需要可自行取消注释 deb http://mirrors.ustc.edu.cn/debian bookworm main contrib non-free non-free-firmware # deb-src http://mirrors.ustc.edu.cn/debian bookworm main contrib non-free non-free-firmware deb http://mirrors.ustc.edu.cn/debian bookworm-updates main contrib non-free non-free-firmware # deb-src http://mirrors.ustc.edu.cn/debian bookworm-updates main contrib non-free non-free-firmware # backports 软件源，请按需启用 # deb http://mirrors.ustc.edu.cn/debian bookworm-backports main contrib non-free non-free-firmware # deb-src http://mirrors.ustc.edu.cn/debian bookworm-backports main contrib non-free non-free-firmware 系统更新与软件安装\rapt update \u0026amp;\u0026amp; apt upgrade\n首次配置一定要大更新一下系统软件，在配置好服务之后，就不要轻易执行 apt upgrade 了。\n再安装一些常用软件：\napt install sudo\napt install git openssl gh\napt install build-essential\napt install screen\n配置sshd\rapt-get install openssh-server\n配置端口转发:\n（可选，便于vscode远程插件连接）\n编辑 /etc/ssh/sshd_config\n增加或修改:\nGatewayPorts yes\nTCPKeepAlive yes\n重启sshd:\nsudo systemctl restart sshd\n配置sudo\r添加用户至sudo文件：\nnano \\etc\\sudoer\n添加一行：\nztc ALL=(ALL:ALL) NOPASSWD:ALL\n或者将用户加入到 sudo 用户组中（推荐）：\n1 usermod -a -G sudo ztc 安装Python12.7\r参考：Linux编译Python\n安装Docker\r参考： Docker安装教程\nDocker换源\r修改配置文件，没有则新增这个文件\nnano /etc/docker/daemon.json\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://hub.xdark.top\u0026#34;, \u0026#34;https://hub.littlediary.cn\u0026#34;, \u0026#34;https://dockerpull.org\u0026#34;, \u0026#34;https://hub.crdz.gq\u0026#34;, \u0026#34;https://docker.1panel.live\u0026#34;, \u0026#34;https://docker.unsee.tech\u0026#34; ] } 保存后重启一下Docker：sudo systemctl daemon-reload \u0026amp;\u0026amp; sudo systemctl restart docker\n查看是否生效：sudo docker info\n末尾如果显示了替换的Hub源，说明换源成功了。\n安装Docker管理界面Portainer\r参考： Portainer安装\n","date":"2025-05-15T20:10:52+08:00","permalink":"https://blog.ztcdream.com/p/debian%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%90%AD%E5%BB%BAdocker%E7%8E%AF%E5%A2%83/","title":"Debian服务器初始化及搭建docker环境"},{"content":"初识LaTex数学公式\r我们已经知道，计算机能够显示文字，大致要经历下面的过程：将文字 编码 ，利于计算机的识别与存储；显示文字时 解码 ，依据编码系统将文字进行翻译；最后是 渲染，将文字以可见的形式显示，通常是显示文字对应的矢量图。\n对于每一个文字，可以设计好一套编解码系统，对应编码设计对应的文字矢量图。这样就可以实现 文字 -\u0026gt; 编码 -\u0026gt; 矢量图 的 映射。\n那么，复杂的数学公式是否可以像文字一样简单地表示呢？\n在概率论中，正太分布的分布函数为：\n$$ F(x) = \\frac{1}{\\sqrt{2 \\pi} \\sigma} \\int_{- \\infty}^{x} e^{-\\frac{(x- \\mu)^2}{2 \\sigma^2}} dx. $$这是一个相当复杂的公式：包含了分数、根号、指数、积分符号和特殊常数（圆周率和自然对数底）。\n用 LaTex 可以很简单地表示：\n1 F(x) = \\frac{1}{\\sqrt{2 \\pi} \\sigma} \\int_{- \\infty}^{x} e^{-\\frac{(x- \\mu)^2}{2 \\sigma^2}} dx. LaTex 本质上与 HTML 一样，都是 标记语言，用于代码化地组织和构建文本、图像等 元素，并将 元素 可视化。在数学公式方面， LaTex 几乎是所有前端的首选项。\nLaTex数学公式\r在LaTex中，数学公式要包含在 $$，\\[ \\]等声明符号内，表明内部是数学公式的代码。最常见的是使用 $ $。\n如表示刚才的正太分布函数，可以写成：\n1 2 3 $$ F(x) = \\frac{1}{\\sqrt{2 \\pi} \\sigma} \\int_{- \\infty}^{x} e^{-\\frac{(x- \\mu)^2}{2 \\sigma^2}} dx. $$ LaTex数学公式是有着一定的结构的。{ } 内的代码将会是一个整体，^{ } 表示上标，_{ } 表示下标。当一个元素既有上标又要下标时，先写下标再写上标。\n如表示一个全排列数：\n$$ A_5^3 $$ 1 2 3 $$ A_5^3 $$ 其他常用的标志符：\n分式\n\\frac{分子}{分母}\n四则运算\n加法：+\n减法：-\n乘法：\\times\n除法：\\div\n微积分\n极限：\\lim\n$$ \\lim $$求导：f^{\\prime}\n$$ f^{\\prime} $$积分：\\int\n$$ \\int $$累加：\\sum\n$$ \\sum $$ 矩阵\n表示中括号矩阵：\n1 2 3 4 5 6 $$ \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\end{bmatrix} $$ $$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\end{bmatrix} $$表示大括号矩阵：\n1 2 3 4 5 6 $$ \\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\end{pmatrix} $$ $$ \\begin{pmatrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\end{pmatrix} $$表示行列式：\n1 2 3 4 \\begin{vmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\end{vmatrix} $$ \\begin{vmatrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\end{vmatrix} $$这其实不是一个行列式，但仍然可以被“正确”地表示。LaTex只关注公式的形式，而非真正的数学意义。\nLaTex的练习环境\rCTex\rCTex 是LeTex的中国版，提供完整的 LaTex 环境和针对中文的调教。\n官网：CTex官网\nWPS\r从2025年开始，WPS新增了LaTex公式的支持。在文档里点击插入 -\u0026gt; 公式 -\u0026gt; 插入LaTex公式\nKaTex.js\r如果你懂前端，可以将KaTex.js包导入到网站中，在网页中使用数学公式，例如本站就是。\njs包官网：KeTex.js\n小测\r请用 LaTex 格式书写下面题目的解题过程（很简单）：\n1\r（微积分）求定积分：\n$$ \\int_0^1 \\frac{1}{(x+1)(x^2-2x+2)}dx. $$2\r（物理）$10g$ 氢气吸收 $1000J$ 的热量时，压强未发生改变，它原来的温度是 $300K$ ，最后的温度是多少？\n3\r（概率论）一个群体中有一下个体：\n$k$个纯合显性个体（AA）\n$m$个杂合子个体（Aa）\n$n$个纯合隐性个体（aa）\n​要求​：计算随机选取两个个体交配时，后代携带至少一个显性等位基因（即表现为显性性状）的概率。假设任意两个个体均可交配。\n","date":"2025-05-14T17:53:22+08:00","permalink":"https://blog.ztcdream.com/p/latex%E6%A0%B8%E5%BF%83%E5%87%BA%E8%A3%85%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","title":"LaTex核心出装——数学公式"},{"content":"实验背景\r时间复杂度 是为了计量算法的运行效率而提出的概念。\n估测一个代码运行效率最简单的办法是记录程序的运行时间，运行时间短则效率高。但程序的运行时间往往受到计算机硬件、操作系统、编程语言和编译器等的影响。对于同一个程序，在14代Intel CPU上运行，普遍比12代 Intel CPU快；同样的代码，在Linux上可能比Windows平台快；同样的算法，用c语言实现的可能比Python实现的快；同一个c语言代码，经过clang编译可能比g++编译的更快。\n因此需要一个定量的计量方法，把算法的实际运行时间抽象为理论执行步数。计算时间复杂度，最广泛使用的是 大O记法。用 $T(n)$ 来表示程序的执行步数，参数 $n$ 为问题规模。$T(n)$是关于 $n$ 函数，当 $n$ 很大时，$T(n)$ 中的很多项可以忽略不记，如\n$$\rT(n) = 5n^3 + 3n^2 + 2log_2n + 10000\r$$当 $n \\to \\infty$ 时，$3n^2$，$2log_2n$，$10000$ 在 $5n^3$ 面前显得很小，可以舍去。$n$ 的三次项的系数 $5$ 也影响不大，也可以舍去。最后就有\n$$\rT(n) \\sim n^3\r$$因此记该算法的大$O$记法为 $O(n^3)$。\n常见的大 $O$ 函数 $f(n)$ ：\n$f(n)$ 名称 $1$ 常数 $logn$ 对数 $n$ 线性 $nlogn$ 线性对数 $n^2$ 平方 $n^3$ 立方 $2^n$ 指数 对于为 $O(1)$ 的程序，时间复杂度不会随问题规模 $n$ 的增大而增大，即 $T(n)=k$ 。\nPython 中有一个特别的数据结构：列表。列表不同于数组，允许列表内元素有不同的数据类型。列表内的元素可以通过索引来访问，和数组的下标一样，都是从 $0$ 开始编号的。\n那么Python中列表索引的具体实现算法的时间复杂度如何？索引所需要的运行时间会不会随列表的长度 $n$ 的变化而变化呢？答案是不变的。Python列表的索引并不依赖于列表的长度，列表的长度发生变化，对一次索引的时间没有影响。\n我们可以通过实验来验证： Python中列表索引的时间复杂度为常数阶 。\n实验原理\rtimeit 是Python中的一个程序运行计时模块。通过 timeit 创建一个 Timer 对象，设置要执行的语句，在通过 Timer.timeit()方法来运行，返回这条语句的运行时间。\n实验代码\r导入库\r1 2 3 import csv from timeit import Timer import matplotlib.pyplot as plt 实验主体\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 def labmain(filename): # 实验主体，生成实验数据 ls = [] n = 10000 endtimes = n fnew = open(filename,\u0026#34;w\u0026#34;,newline=\u0026#34;\u0026#34;) csv_writer = csv.writer(fnew) for i in range(endtimes): ls.append(i) t1 = Timer(f\u0026#34;ls[{i}]\u0026#34;,globals={\u0026#39;ls\u0026#39;: ls}) writerow = [i,f\u0026#34;{t1.timeit(number=100000):.8f}\u0026#34;] csv_writer.writerow(writerow) fnew.close() t1.timeit(number=100000) 中的 number 设置执行的总次数。\n数据可视化\r实验主体函数将每次的运行结果写入 csv 文件，每行两个数据，一个是执行的次数序号 $n$ ，一个是程序运行时间 $y$ 。\n通过 matplotlib.pyplot 可以把对应的 $x-y$ 散点图绘制出来，直观的感受 $y$ 与 $x$ 的关系。\n1 2 3 4 5 6 7 8 9 10 11 12 # 数据可视化 def plot_func(csvfile): fo = open(csvfile,\u0026#34;r\u0026#34;) reader = csv.reader(fo) x_list = [] y_list = [] for row in reader: x_list.append(int(row[0])) y_list.append(float(row[1])*100) plt.scatter(x=x_list, y=y_list,s=3) plt.show() fo.close() 回归分析\r检查 $x_i$ , $y_i$ 是否满足方程 $y=k$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def reg_func(filename): fo = open(filename,\u0026#34;r\u0026#34;) reader = csv.reader(fo) x_list = [] y_list = [] for row in reader: x_list.append(int(row[0])) y_list.append(float(row[1])*100) # 计算 sum_(x/y)i, sum_(x/y)i^2, sum_xi*yi sum_xi = sum(x_list) sum_yi = sum(y_list) sum_xi2 = sum(i**2 for i in x_list) sum_yi2 = sum(j**2 for j in y_list) sum_xiyi = sum([a * b for a, b in zip(x_list, y_list)]) l_xx = sum_xi - sum_xi2**2/len(x_list) l_yy = sum_yi - sum_yi2**2/len(y_list) l_xy = sum_xi - sum_xi*sum_yi/len(x_list) b = l_xy / l_xx a = sum_yi/len(y_list) - b*sum_xi/len(x_list) # 计算相关系数 rate_r = l_xy / pow(l_xx*l_yy, 2) return b,a,rate_r 主函数及运行结果\r1 2 3 4 5 6 7 8 9 def main(): filename = \u0026#34;索引实验数据.csv\u0026#34; labmain(filename) plot_func(filename) b, a , r = reg_func(filename) print(f\u0026#34;线性回归方程为 y= {b:.4f}x + {a:.4f} 相关系数r = {r:.4f}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 生成的图如下：\n可以看到，随着 $n$ 增大，运行时间 $y$ 均在某个常数附近，只有极少数点偏离了常数。\n控制台输出：\n拟合的回归方程为：\n$$\r\\begin{aligned}\r\\widehat{y} \u0026= -0.0000x+0.1129 \\\\\rr \u0026=0.0000\r\\end{aligned}\r$$可以看到 $x$ 的系数为 $0$ ，且相关系数也为 $0$ ，证明 $y$ 与 $x$ 的函数为常数函数。\n实验结论\r通过对实验数据的分析，证明了Python索引操作的时间复杂度为常数阶。\n","date":"2025-05-13T22:45:17+08:00","permalink":"https://blog.ztcdream.com/p/%E5%AE%9E%E9%AA%8C%E8%AF%81%E6%98%8E%E5%88%97%E8%A1%A8%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E5%B8%B8%E6%95%B0%E9%98%B6/","title":"（实验）证明列表索引操作的时间复杂度为常数阶"},{"content":"问题描述\r​给定​：三个正整数$k$、$m$、$n$，表示一个群体中有：\n$k$个纯合显性个体（AA）\n$m$个杂合子个体（Aa）\n$n$个纯合隐性个体（aa）\n​要求​：计算随机选取两个个体交配时，后代携带至少一个显性等位基因（即表现为显性性状）的概率。假设任意两个个体均可交配。\n推导过程\r这个随机事件可以分解为两步：\n第一步 随机选取两个个体\n第二步 统计所选取的个体交配的后代\n第一步的结果会影响到第二步的结果，因此要用到全概率。\n并且，\n$$\rP(A\\_)=P(AA)+P(Aa)=1-P(aa)\r$$可以逆向先求出 $P(aa)$.\n$$\r\\begin{aligned}\rP(aa) = P(AA,AA)P(aa|AA,AA) \u0026+ P(AA,Aa)P(aa|AA,Aa) +\\\\\rP(AA,aa)P(aa|AA,aa) \u0026+ P(Aa,Aa)P(aa|Aa,Aa) + \\\\\rP(Aa,aa)P(aa|Aa,aa) \u0026+ P(aa,aa)P(aa|aa,aa)\r\\end{aligned}\r$$其中，\n$$\rP(aa|AA,AA)=P(aa|AA,Aa)=P(aa|AA,aa)=0\r$$因此，\n$$\r\\begin{aligned}\rP(aa) \u0026= P(Aa,Aa)P(aa|Aa,Aa) + P(Aa,aa)P(aa|Aa,aa) + P(aa,aa)P(aa|aa,aa) \\\\\r\u0026=\\frac{C_m^2}{C_{k+m+n}^{2}} \\times \\frac{1}{4}+ \\frac{C_m^1C_n^1}{C_{k+m+n}^2} \\times \\frac{1}{2}+ \\frac{C_n^2}{C_{k+m+n}^2} \\times 1 \\\\\r\u0026= \\frac{2C_m^1C_n^1 + 4C_n^2 + C_m^2}{4C_{k+m+n}^2}\r\\end{aligned}\r$$最后，\n$$\r\\begin{aligned}\rP(A\\_) \u0026= 1-P(aa) \\\\\r\u0026= 1 - \\frac{2C_m^1C_n^1 + 4C_n^2 + C_m^2}{4C_{k+m+n}^2}\r\\end{aligned}\r$$","date":"2025-05-02T19:13:02+08:00","permalink":"https://blog.ztcdream.com/p/%E7%BE%A4%E4%BD%93%E6%98%BE%E6%80%A7%E5%90%8E%E4%BB%A3%E9%97%AE%E9%A2%98/","title":"群体显性后代问题"},{"content":"需求\r使用VSCode的远程主机SSH插件时，每次登陆远程服务器均需要手动输入密码，不能保存密码，这是VSCode出于安全考虑而禁用了密码自动登陆。\n如果想实现免密登陆，可以使用ssh密钥登陆。\n配置ssh密钥登陆\r本地创建ssh密钥\r按 Win+R ，输入 powershell 打开终端。打开后默认处于 C:\\Users\\yourname 文件夹。\n执行\n1 ssh-keygen -t rsa -b 4096 连续按三次回车，看到 The key's randomart image is: 表明成功生成ssh密钥。\n如图\n将公钥复制到服务器\rssh密钥是一个密钥对，分为公钥和私钥。私钥放在本地电脑上，理论上具有唯一性。公钥放在服务器上，每当登陆服务器时，服务器端检查公钥是否与本地的私钥配对，确保连接是安全的。\n新生成的密钥默认保存在本地的 ~/.ssh 文件夹下，用 cat .\\ssh\\id_rsa.pub 查看公钥并复制。\n1 cat .\\ssh\\id_rsa.pub 复制后登陆远程服务器，粘贴到 ~/.ssh/authorized_keys 文件中并保存。\n至此，退出vscode然后重进，已经可以免密登陆了。\n小结\r通常连接远程Linux主机时，是不使用密码登陆的，因为这样明文密码安全性极低。本文介绍的ssh密钥登陆对于其他ssh终端如 XShell 、 Tabby 等同样适用。\n","date":"2025-04-29T10:35:43+08:00","permalink":"https://blog.ztcdream.com/p/vscode%E9%85%8D%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/","title":"VSCode配置ssh密钥登陆"},{"content":"问题引入\r网站的静态html文件托管在了github仓库上，每次修改网页构建的文件就git push至github仓库，服务器再git pull拉取仓库，实现网站的更新。\n按照这个流程，每修改一次网站，都要在服务器上执行一次git pull，很不方便。因此要让服务器自动执行这个过程，实现自动化。\n假设网站静态文件仓库在/web/site/index，我们把自动化的脚本放在上一级/web/site1。\n方法一 Crontab定时更新\rcrontab是linux里自带的自动化程序，在crontab -e修改配置文件，定时执行shell命令（通常是运行一个shell脚本），达到自动化的目的。\n创建更新仓库的sh脚本\rnano /web/site1/auto-fetch.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash REPO_DIR=\u0026#34;/web/site1/index\u0026#34; # 切换到git目录 cd \u0026#34;$REPO_DIR\u0026#34; || exit 1 echo \u0026#34;[`date`] Forcing git fetch and reset...\u0026#34; \u0026gt;\u0026gt; /web/site1/git_pull.log # 写入日志 # 取最新远程变更 git fetch origin # 强制把本地重置为远程分支 git reset --hard origin/main # 可选：清理多余文件 git clean -fd echo \u0026#34;[`date`] Update complete\u0026#34; \u0026gt;\u0026gt; /web/site1/git_pull.log 别忘了赋权\n1 chmod +x /web/site1/auto-fetch.sh 配置crontab\r使用crontab -e修改crontab的配置文件\n在末尾加入两行\n1 2 */1 * * * * /bin/bash /web/site1/auto-fetch.sh \u0026gt;\u0026gt; /web/site1/cron-sync.log 2\u0026gt;\u0026amp;1 0 0 * * * \u0026gt; /web/site1/cron-sync.log 第一行 */1 * * * *是每隔一分钟执行一次，运行auto-fetch.sh，并将错误输出连同标准输出写入cron-sync.log。\n第二行是每天0点清空cron-sync.log，避免日志文件无限增大。\n保存退出后，crontab就立即生效了。\n方法二 webhook实时更新\rcrontab的配置过程简单，但缺点是定时。因为是强制更新，因此crontab设置自动更新的时间间隔不宜过短，因为会影响性能。\nwebhook可以实时监听远程仓库的状态，当且仅当远程仓库变化时，服务器才自动push。\n创建更新脚本\r这一步参考crontab的auto-fetch脚本\n编写webhook服务脚本\r这里要用到python的flask模块\npip3 install flask\nnano /web/site1/webhook_server.py\n写入\n1 2 3 4 5 6 7 8 9 10 11 12 from flask import Flask, request import subprocess app = Flask(__name__) @app.route(\u0026#39;/git-webhook\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def webhook(): subprocess.Popen([\u0026#39;/web/site1/auto-fetch.sh\u0026#39;]) return \u0026#39;Webhook received\u0026#39;, 200 if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=9000) 根据自身情况修改 subprocess.Popen的脚本路径 和 port=9000 的端口号。（这个webhook是运行在服务器上的，注意端口是否被占用）\n创建 systemd 服务管理 webhook\rnano /etc/systemd/system/git-webhook.service\n写入\n1 2 3 4 5 6 7 8 9 10 11 12 [Unit] Description=Git Webhook Listener After=network.target [Service] User=root WorkingDirectory=/web/site1 ExecStart=/usr/bin/python3 /web/site1/webhook_server.py Restart=always [Install] WantedBy=multi-user.target 上面的User=root，按需修改成可以执行脚本的用户\n启用并启动\n1 2 3 systemctl daemon-reexec systemctl daemon-reload systemctl enable --now git-webhook.service 查看状态\nsudo systemctl status git-webhook.service\ngithub设置webhook\r点进项目仓库，上边栏找到Settings，点击Webhooks。\n点击Add webhook。\nPayload URL = http://your-server-ip:9000/git-webhook\nContent type = application/json\nEvents = Push events\n保存后检查是否正常工作\n定时清空日志\r仍使用crontab来清空git的日志\n只需要在crontab配置文件加一条即可：\n0 0 * * * \u0026gt; /web/site1//web/site1/git_pull.log\n小结\r如果应付简单的场景，crontab足矣。\n追求实时更新和性能，更推荐监听webhook的方式。\n","date":"2025-04-20T17:15:09+08:00","permalink":"https://blog.ztcdream.com/p/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%93%E5%BA%93/","title":"服务器自动拉取仓库"},{"content":"这不对吧？从一个例子讲起\r请读者先仔细观察下面的代码\n1 2 3 4 5 int a=8; if (a\u0026lt;9){ int b=a; } cout\u0026lt;\u0026lt;b; 提问：上面会输出什么？\n你心想：这还用问，b=a=8，当然输出8了。\n然而，结果却是\n'b' was not declared in this scope\n这不对吧？为什么b是未定义的？这是因为c语言中有作用域的概念。\n代码块\rc++中用花括号 { } 标识一个代码块, { } 内的所有语句被视为一句语句。在if,while,for等控制语句中经常用到。\n块级作用域\rc语言规定 { }里新定义的变量，只能在当前{ }里使用 ，即 块级作用域 。\n1 2 3 4 int a; { int b; } 上面 { } 内的变量b，只能在 { } 里使用。\n下面的例子更是典型：\n1 2 3 4 for(int i=0;i\u0026lt;8;i++){ continue; } cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; 上面的输出是什么？\n答案不是输出9。因为这里的for语句就是一个代码块，在里面新定义的变量只能在for语句中使用。\n想让for语句结束后输出变量i，那么变量i必须在for语句之前定义。\n下面两种方案是可行的：\n1 2 3 4 5 int i; for(i=0; i\u0026lt;8; i++){ continue; } cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; 或\n1 2 3 4 5 int i=0; for(; i\u0026lt;8; i++){ continue; } cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; 作用域遮蔽(Shadowing)\r{ } 代码块外部若已定义一个变量，在 { } 里允许对该变量重新定义，且仅在该代码块内失效。\n1 2 3 4 5 6 int a=0; { float a=5.6; cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl; 输出 $5.6$ 和 $0$\n函数作用域\r在自定义函数里定义的普通变量，是局部变量，仅在该函数体内可用。\n特别要注意的是，main函数也是函数，在main里定义的变量在自定义函数里是无法直接使用的。\n1 2 3 4 5 6 7 8 9 10 ... int main(){ int a=5; couta(); ... } void couta(){ cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl; } 这里couta函数无法使用a，因为a是main的局部变量。\n要想在couta()里使用a，可以在main前初始化a。\n1 2 3 4 5 6 7 8 9 10 11 12 ... int a; int main(){ a=5; couta(); ... } void couta(){ cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl; } 总结\r块级作用域 { }，可以简单理解成中央与地方的关系。\n{ } 外面的变量相当于是中央文件， { } 内部的变量看作地方法规。中央出台的文件对所有地方省份都生效，各省份可以根据自身情况修改中央文件，或者制定新的法规。地方修改后的中央文件和新法规也仅对该区域生效，不会影响到中央和其他地方省份。\n小测\r1\r下面的for循环可以完整输出字符数组strA的所有内容吗？如果不能，请改正。\n1 2 3 4 5 6 7 8 ... int i=0,j=0; char strA[2][6]={\u0026#34;Hello\u0026#34;,\u0026#34;world\u0026#34;}; for (; i\u0026lt;2; i++){ for (; j\u0026lt;5; j++){ cout\u0026lt;\u0026lt;strA[i][j]; } } 2\r下面的语句能不能判断a是不是质数？如果不能，请更正。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ... int a; a=11; for(int i=2; i\u0026lt;2; i++){ if (a/i==0){ break; } } if (i==a){ cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;是质数\u0026#34;\u0026lt;\u0026lt;endl; } else{ cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;不是质数\u0026#34;\u0026lt;\u0026lt;endl; } 3\r思考下面代码的运行结果：\n1 2 3 4 5 6 7 8 9 10 ... int a,b,c; a=3,b=5,c=8; { c=b; int b=a; cout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;c; ","date":"2025-04-20T17:09:00+08:00","permalink":"https://blog.ztcdream.com/p/%E6%98%93%E9%94%99c-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A6%82%E5%BF%B5/","title":"（易错）C++的作用域概念"},{"content":"错误呈现\r给出$3$阶矩阵$|A|=\\frac{1}{2}$，求$|A^*|$.\n一看有$|A|$和$|A^*|$，很容易联想到伴随矩阵的性质：\n$$\rAA^*=A*A=|A|E\r$$则\n$$\r\\begin{aligned}\r|AA^*| =|A||A^*|\u0026=||A|E| \\\\\r\u0026= |A||E| \\\\\r\u0026= |A|\r\\end{aligned}\r$$两边约去$|A|$，得\n$$\r|A^*|=1\r$$似乎题目给出的$|A|=\\frac{1}{2}$是多余的。\n错误分析\r但是，这对吗？\n这不对！\n问题就出在将$||A|E|$最外层的 $||$去掉这一步\n$$\r\\begin{aligned}\r||A|E| \u0026 \\ne |A||E| \\\\\r||A|E| \u0026= |A|^3|E| \\\\\r\u0026= |A|^3\r\\end{aligned}\r$$总结\r因此对于一个$n$阶矩阵$A$，$A$可逆，那么伴随矩阵：\n$$\r\\begin{aligned}\r|A^*|=|A|^{n-1}\r\\end{aligned}\r$$","date":"2025-04-16T20:39:48+08:00","permalink":"https://blog.ztcdream.com/p/%E6%98%93%E9%94%99%E6%B1%82%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F/","title":"（易错）求伴随矩阵的行列式"},{"content":"问题\rcpp中使用cin输入数字，像05,08这样的输入，并不能转换成我们预期的5和8。原因是以0开头的整数被视为八进制数，如果输入08，八进制里没有\u0026quot;8\u0026quot;，会直接报错。\n那如果用户一定要输入以0开头的整数，该如何解决呢？\n解决方案\r字符串转换\ratoi函数\r$atoi$ 函数是c语言就有的函数，可以把字符串转换为int整数。\n原型为 int atoi(const char *str)\n工作原理：调用atoi时，从左开始扫描字符串，遇到首个非空字符且为数字或字符号开始转换，直到遇到非数字字符或\u0026rsquo;\\0\u0026rsquo;时停止，并返回转换后的整数，其余情况返回0。\n正常用法：\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char a[]=\u0026#34; 0122 d\u0026#34;; cout\u0026lt;\u0026lt;atoi(a); return 0; } 返回$122$\n不当用法：\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char a[]=\u0026#34; -+0122 \u0026#34;; cout\u0026lt;\u0026lt;atoi(a); return 0; } 默认返回$0$\n相似的函数还有：\nitoa()\n将整数转为字符串\natof\n将字符串转为浮点型\n","date":"2025-03-28T23:33:29+08:00","permalink":"https://blog.ztcdream.com/p/c%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%86%B3%E6%95%B4%E6%95%B0%E5%89%8D%E6%9C%890%E7%9A%84%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/","title":"C语言解决整数前有0的输入问题"},{"content":"激活工具\rHEU_KMS_Activator\r项目地址 https://github.com/zbezj/HEU_KMS_Activator\n下载直链 HEU_KMS_Activator_v42.3.1\n压缩工具\r360压缩国际版\r官网地址 https://www.360totalsecurity.com/en/360zip/\n下载直链 360ZIP.exe\n安全软件\r火绒安全软件\r官网地址 https://www.huorong.cn/\n下载直链 火绒安全6.0\n注册表优化\rDismm++\r项目地址 https://github.com/Chuyu-Team/Dism-Multi-language\n下载直链 Dism++\n剪贴板\rCopyQ\r项目地址 https://github.com/hluk/CopyQ/\n下载直链 CopyQ\n音量控制\rEarTrumpet\r项目官网 https://github.com/File-New-Project/EarTrumpet\n下载直链 EarTrumpet\n截图\rSnipaste\r官网地址 https://zh.snipaste.com/\n哈希校验\rHashCaculator\r项目地址 https://github.com/hrpzcf/HashCalculator 下载直链 HashCaculator\n代理工具\rNekoray\r项目地址 https://github.com/MatsuriDayo/nekoray\n下载直链 nekoray.zip\nTailscale\r官网地址 https://www.tailscale.com\n","date":"2025-01-17T23:01:01+08:00","permalink":"https://blog.ztcdream.com/p/win%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/","title":"Win系统工具"},{"content":"先上例题\r设函数$f$有二阶连续偏导，且$z=f(xy,x+y)$.\n求\n$$\r\\frac{\\partial^2z}{\\partial xy} $$分析\r求二阶偏导，先求出一阶偏导。 当二阶偏导连续，有：\n$$\r\\frac{\\partial^2z}{\\partial xy} = \\frac{\\partial (\\frac{\\partial x}{\\partial y})}{\\partial x} = \\frac{\\partial(\\frac{\\partial z}{\\partial x})}{\\partial y} $$\n注意到$f_1$和$f_2$均有$(xy),(x+y)$的变量\n总结\r对于抽象函数\n$$\rz = f(g_1,g_2,g_3 \\dots)\r$$其中，$g_1,g_2,g_3,\\dots$是关于$x,y$的二元或一元函数\n则，\n$$\r\\begin{aligned}\r\\frac{\\partial z}{\\partial x} \u0026 = f_1g_{1_x} + f_2g_{2_x} + f_3g_{3_x} +\\dots \\\\\r\\frac{\\partial^2z}{\\partial xy} \u0026= \\frac{d(g_{1_x})}{dy}f_1+g_{1_x}(f_{11}\\frac{\\partial g_1}{\\partial y}+f_{12}\\frac{\\partial g_2}{\\partial y}+\\dots) + \\dots\r\\end{aligned}\r$$注意到，$f_1$仍然是包含$g_n$的函数。例如\n$$\r\\begin{aligned}\rz \u0026 = f(u,v) = u^v \\\\\r\\frac{\\partial z}{\\partial u} \u0026= f_1(u,v)=vu^{v-1}\r\\end{aligned}\r$$","date":"2025-01-06T18:22:38+08:00","permalink":"https://blog.ztcdream.com/p/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E4%BA%8C%E9%98%B6%E5%81%8F%E5%AF%BC/","title":"多元函数二阶偏导"},{"content":"图\r","date":"2025-01-04T19:01:40+08:00","permalink":"https://blog.ztcdream.com/p/%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%81%8F%E5%BE%AE%E5%95%86%E4%B8%8E%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"二元函数偏微商与连续的关系"},{"content":"最大公因数问题\r任给两个不全为零的整数，必存在一个的数，它同时是两个数的因子，这个数称为公因数。\n不互质的两个数的公因数可以有多个，寻找最大的公因数就被称为最大公因数问题。\n设有两个非零整数$a,b$，其最大公因数可表示为\n$$\r(a,b) $$例如，\n$$\r(4,6) = 2\r$$短除法\r小学二年级时我们已经知道，可以使用短除法来先找出所有的较小公因数，再把他们相乘。\n例如求$(12,16)$，\n对于较小的整数，这个方法也蛮好用的，但对于稍大的数，我们很难看出除数是几。比如$(5423,3157)$，使用短除法，找第一个除数都要花不少时间。\n不难看出，短除法的思路是不断将两个数同时倍比缩小，直到无法继续同除一个数，在这个过程中也就找到了这个最大公因数的因式。但关键在于无法确定每一步的除数，实际情况可能是一个一个试，保险起见还可能是从小到大试。这样的复杂度无异于直接将两数都分解，但我们只需要最大公因数，而我们却多此一举，找出了这个数的因式。\n依据这个算法，可以写成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def gcd_short_division(a, b): if a \u0026lt; b: a, b = b, a # 确保 a 是较大的数 divisor = 2 # 从最小的质数开始 gcd = 1 # 初始最大公约数为 1 while a \u0026gt;= divisor and b \u0026gt;= divisor: if a % divisor == 0 and b % divisor == 0: # 如果 divisor 是 a 和 b 的公因数 gcd *= divisor a //= divisor b //= divisor elif a % divisor == 0: a //= divisor # 只对 a 进行除法 elif b % divisor == 0: b //= divisor # 只对 b 进行除法 else: divisor += 1 # 尝试下一个更大的因数 return gcd 辗转相除法\r定理：设整数$a/b$的余数为$r$,则\n$$(a,b)=(b,r)$$通过不断重复，直到$b_i/r_i=c$可以整除，那么$(a,b)=r_i$\n以$(5423,3157)$为例，\n最后$22/11=2$，最后的除数$11$就是最大公因数。\n代码实现\r该算法是循环过程，当$a\u0026gt;b$时，运算r_1=a%b ，重复r_i=b_(i-1)%r_(i-1)，直到r_i=0，输出r_(i-1)。\n代码实现如下，\n1 2 3 4 5 6 7 8 9 10 def gcd_euclidean(a, b): while b != 0: a, b = b, a % b return a # 测试 a = 3157 b = 5423 gcd = gcd_euclidean(a,b) print(gcd) 注意到，这里不用判断$a,b$的大小,如果 $a\u0026lt;b$，第一次相除后变成了gcd(b,a)\n对比短除法，可谓是相当简洁了。\n最小公倍数问题\r求一个两个数的最小公倍数$(GCD)$，可以用\n$$\r\\begin{aligned}\rlcm(a,b) = \\frac{|a \\times b|}{gcd(a,b)}\r\\end{aligned}\r$$已知最大公因数，即可求出最小公倍数\n代码实现\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 def lcm_euclidean(a,b): c = a d = b while d != 0: c, d = d, c % d lcm = abs(a*b)/c return lcm # 测试 a = 24 b = 28 lcm = lcm_euclidean(a,b) print(lcm) ","date":"2024-12-31T16:19:08+08:00","permalink":"https://blog.ztcdream.com/p/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/","title":"辗转相除法"},{"content":"先上图\r公式\rb=ac\r任意函数等于相邻函数的乘积\n例如，\n$$\r\\begin{aligned}\r\\tan x \u0026 =\\sec x \\sin x \\\\\r\\sin x \u0026 =\\tan x \\cos x \\\\\r\\end{aligned}\r$$平方和与1的关系\r我们知道，\n$$\r\\sin^2 x + \\cos^2 x = 1\r$$实际上，对应图中所有的最小倒立三角形，\n1 底部平方 = 上面两个的平方和 例如，\n$$\r\\begin{aligned}\r\\sin^2 x + \\cos^2 x \u0026=1 \\\\\r\\tan^2 x + 1 \u0026= \\sec^2 x \\\\\r1 + \\cot^2 x \u0026= \\csc^2 x\r\\end{aligned}\r$$求导积分\r记住口诀\n1 2 中下二，下中下 \\\\ 导相乘，对对和 无论求导还是积分，中间的函数($\\tan x,\\cot x$)积分/求导后，只与其下方的函数有关；下方的函数求导/积分，与中间和下方（自己）有关。\n如果是求导，则相乘；积分则相加，加绝对值，取对数。\n例如，$\\tan x$，\n找相关函数。\n$tan x$在中间，由中下二，求导/积分后与 $\\sec x$,$\\sec x$有关,即$D(\\sec x,\\sec x)$\n确定运算符\n如果是求导，则相乘：$\\sec x \\times \\sec x$。积分，相加，加绝对值，取对数:$\\ln|\\sec x+\\sec x|$\n确定正负，积分加C\n左边的函数求导/积分为正，右边为负。\n$$\\int\\tan xdx=-\\ln |2\\sec x|+C$$ 适当化简\n如$-\\ln |2\\sec x|+C=-\\ln |\\sec x|+C$\n笔记附图\r","date":"2024-12-30T19:54:39+08:00","permalink":"https://blog.ztcdream.com/p/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%B7%A7%E8%AE%A1%E4%B8%89%E8%A7%92%E6%B1%82%E5%AF%BC%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F/","title":"一张图巧计三角求导积分公式"},{"content":"题干\r$$\r\\int_0^1 \\frac{1}{(x+1)(x^2-2x+2)}dx.\r$$解题\r设\r$$\r\\frac{1}{(x+1)(x^2-2x+2)}=\\frac{A}{x+1}+\\frac{Bx+D}{x^2-2x+2}\r$$通分\r$$\r(A+B)x^2+(B+D-2A)x+2A+D-1=0\r$$列方程组\r$$\r\\left \\{\r\\begin{aligned}\r\u0026 A+B=0 \\\\\r\u0026 D+B-2A =0 \\\\\r\u0026 2A+D-1 =0\r\\end{aligned}\r\\right.\r$$解得\n$$\r\\left \\{\r\\begin{aligned}\r\u0026 A=\\frac{1}{5} \\\\\r\u0026 B=-\\frac{1}{5} \\\\\r\u0026 D=\\frac{3}{5}\r\\end{aligned}\r\\right.\r$$代入\r$$\r\\frac{1}{(x+1)(x^2-2x+2)}=\\frac{1}{5(x+1)}+\\frac{-x+3}{5(x^2-2x+2)}\r$$剩下的就是有理函数的积分的内容了\n","date":"2024-12-30T11:23:47+08:00","permalink":"https://blog.ztcdream.com/p/%E8%80%83%E7%A0%94%E9%A2%98-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/","title":"考研题-不定积分"},{"content":"定义\r约定有理真分式 $$\\frac{P(x)}{Q(x)}=\\frac{P(x)}{c_0(x-a)^k(x^2+px+q)^l}$$ ,（其中$k$,$l$是正整数，$p^2-4q\u0026lt;0$） 可唯一因式分解为有限个最简有理分式之和，即 $$\r\\frac{P(x)}{Q(x)}=\\frac{A_1}{x-a}+\\frac{A_2}{(x-a)^2}+\\cdots+\\frac{A_k}{(x-a)^k} + \\frac{B_1x+D_1}{x^2+px+q}+\\frac{B_2x+D_2}{x^2+px+q}+\\cdots+\\frac{B_lx+D_l}{x^2+px+q}\r$$化简\r一些例题往往不是上面的形式，但有的可以进行化简。\n分母化低次\r例如分母为$(x+1)^3(x^3+1)^2$，其中的\n$$\r\\begin{split}\r(x^3+1)^2 \u0026= (x+1)^2(x^2-x+1)^2\r\\end{split}\r$$因此分母可写为，\n$$\r(x+1)^5(x^2-x+1)^2\r$$分子化低次\r如果分母没问题，分子次数太高，需保证该分式为真分式。\n求出$A_i,$ $B_l,$ $D_l$\r待定系数\r一言不合，直接开干。\n直接通分后列出关于$A_i,$ $B_l,$ $D_l$的等式组，解出对应值。\n优点：\n容易想到 简单的式子好用 缺点：\n难通分，通分时写许多式子，打开平方等 举教材中的一个例题\n$$\r\\int \\frac{x+2}{(2x+1)(x^2+x+1)} dx\r$$可设\n$$\r\\frac{x+2}{(2x+1)(x^2+x+1)} = \\frac{A}{2x+1} + \\frac{Bx+D}{x^2+x+1}\r$$化简\n$$\r\\begin{aligned}\rx+2 \u0026= A(x^2+x+1)+(Bx+D)(2x+1) \\\\\r\u0026= (A+2B)x^2 + (A+B+2D)x +A+D\r\\end{aligned}\r$$对应次数前的系数相等，因此\n$$\r\\left \\{\r\\begin{aligned}\r\u0026 A+2B = 0 \\\\\r\u0026 A+B+2D = 1 \\\\\r\u0026 A + D =2\r\\end{aligned}\r\\right.\r$$解得，\n$$\r\\left \\{\r\\begin{aligned}\r\u0026 A =2 \\\\\r\u0026 B =-1 \\\\\r\u0026 D = 0\r\\end{aligned}\r\\right.\r$$因此，原积分化为\n$$\r\\begin{aligned}\r\\int \\frac{x+2}{(2x+1)(x^2+x+1)} dx \u0026= \\int (\\frac{2}{2x+1}-\\frac{x}{x^2+x+}) dx \\\\\r\u0026= \\int \\frac{2}{2x+1}dx- \\int \\frac{x}{x^2+x+1} dx\r\\end{aligned}\r$$留数法\r当设出\n$$\r\\frac{x+2}{(2x+1)(x^2+x+1)} = \\frac{A}{2x+1} + \\frac{Bx+D}{x^2+x+1}\r$$想要不通分，因为通分过程相当耗时，最后得到的一次方程组也不一定好解。 因此用留数和极限的技巧将A,B,D解出\n求一次项待定系数A\r如求$A$,两边乘上$A$下的分母$(2x+1)$,让$A$的分母消失\n$$\r\\frac{x+2}{x^2+x+1}=A+\\frac{(Bx+D)(2x+1)}{x^2+x+1}\r$$再令$2x+1=0$，即$x=-\\frac{1}{2}$，让$A$右边的等式消失\n$$\r\\begin{aligned}\r\\frac{x+2}{x^2+x+1} \u0026 = A \\\\\r\\end{aligned}\r$$这时，直接得到A的分式，带入$x=-\\frac{1}{2}$即可\n$$\rA=\\frac{-\\frac{1}{2}+2}{(-\\frac{1}{2})^2+(-\\frac{1}{2})+1}=2\r$$求二次项的待定系数B,D\r仿照上面求$A$的思路，不难想到也是两边乘上$(x^2+x+1)$，\n$$\r\\frac{x+2}{2x+1}=\\frac{A(x^2+x+1)}{2x+1}+Bx+D\r$$再令$x^2+x+1=0$，解出$x$\n注意到，$x$的解是两个复数根，不好求，求出来代入也不好化简。因此要另想办法。\n回到刚才求$A$时，两边乘上$(2x+1)$\n$$\r\\begin{aligned}\r\\frac{x+2}{x^2+x+1}=A+\\frac{(Bx+D)(2x+1)}{x^2+x+1}\r\\end{aligned}\r$$两边同时取$x \\to \\infty$的极限\n$$\r\\begin{aligned}\r\\lim_{x \\to \\infty}\\frac{x+2}{x^2+x+1} \u0026 = \\lim_{x \\to \\infty} [A+\\frac{(Bx+D)(2x+1)}{x^2+x+1}] \\\\\r0 \u0026= 2 + \\lim_{x \\to \\infty}\\frac{2Bx^2+2Dx+Bx+D}{x^2+x+1} \\\\\rB \u0026= -1\r\\end{aligned}\r$$再令$x=0$，（也可以是其他好算的值）\n$$\r\\begin{aligned}\r2 \u0026 = A + D \\\\\rD \u0026= 2-A =0\r\\end{aligned}\r$$","date":"2024-12-25T18:05:10+08:00","permalink":"https://blog.ztcdream.com/p/%E5%88%86%E6%AF%8D%E4%BD%8E%E6%AC%A1%E5%B9%82%E7%A7%AF%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/","title":"分母低次幂积型的不定积分"},{"content":"基本三角函数的积分\r$$\\int \\sin x dx=-\\cos x+C$$ $$\\int \\cos x dx=\\sin x+C$$ $$\\int \\tan x dx=-\\ln |\\cos x|+C$$ $$\\int \\sec x dx = \\ln |\\sec x + \\tan x|+C$$ $$\\int \\csc x dx = \\ln |\\csc x - \\cot x|+C$$ 类型1\r$$\\int \\frac{1}{(x^2-2x+2)^2}dx$$分母为二次最简式，尝试写成$((x-c)^2+A)^2$的形式。 分母\n$$(x^2-2x+2)^2 = ((x-1)^2+1)^2$$ 令$x-1=\\tan x$，则$x=\\tan x +1$\n分母为$((\\tan t)^2+1)^2=\\sec^4 t$\n$dx = \\sec^2 t$\n于是，原式为\n$$\r\\begin{split}\rI \u0026= \\int \\frac{1}{(x^2-2x+2)^2}dx \\\\\\\\\r\u0026= \\int \\frac{1}{\\sec^4 t} \\sec^2 t dt \\\\\\\\\r\u0026= \\int \\cos^2 t dt \\\\\\\\\r\u0026= \\frac{t}{2}+\\frac{\\sin 2t}{4}+C \\\\\\\\\r\u0026= \\frac{t}{2}+\\frac{\\sin t \\cos t}{2}+C \\\\\\\\\r\\end{split}\r$$注意到， 在三角形中，\n","date":"2024-12-14T16:10:48+08:00","permalink":"https://blog.ztcdream.com/p/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%AF%E5%88%86/","title":"三角函数的积分"},{"content":"什么是有理函数\r设$f(x)$是定义在$D$上的函数，若存在$F(x)$，使得$f(x)$在$D$上的任一开区间上都有定义，且$F(x)$在$D$上连续，则称$F(x)$为$f(x)$的原函数，记作$F(x)=f(x)+C$，其中$C$是任意常数。\n对于一个函数$f(x)$，若$f(x)$可以表示为以下形式： $$\rf(x)=\\frac{P(x)}{Q(x)}\r$$ 其中$P(x)$和$Q(x)$是两个多项式函数，且$Q(x)$的最高次项系数不为0，则称$f(x)$为有理函数。\n有理函数的积分方法\r接下来逐级讨论不同复杂度的积分方法。这里设$P(x)$的最高次项为$p$，$Q(x)$的最高次项为$q$。\np=0, q\u0026gt;0的类型\r$$\\int \\frac{1}{x}dx$$ $$\\int \\frac{1}{x+3}dx$$此类型可直接找出原函数，如(2)为 $ln|x+3|+C$。\n类似的， $$\r\\int \\frac{1}{1+x^2} dx= \\frac{1}{2} \\arctan x +C,\r$$$$\r\\int \\frac{1}{x^q}dx = \\frac{x^{1-q}}{1-q} +C\r$$$$\r\\int \\frac{1}{ax+b} dx = \\frac{1}{a} \\ln |x+\\frac{b}{a}| +C\r$$将x升高次数，令q=2\n$$\\int \\frac{1}{x^2+3}dx$$ 此类型分母可以写成 $(x-c)^2 \\pm a^2$的形式。\n如为$x^2+a^2$,\n$$\r\\int \\frac{1}{x^2+a^2} dx = \\frac{1}{a} \\arctan (\\frac{x}{a}) +C\r$$ $$\\int \\frac{1}{x^2-3} dx$$ 该题与题$3$一样，不过分母变为$x^2-(\\sqrt{3})^2$,\n如果分母为$x^2-a^2$,\n$$\r\\int \\frac{1}{x^2-a^2} dx = \\frac{1}{2a} \\int (\\frac{1}{x-a}-\\frac{1}{x+a}) dx = \\frac{1}{2a} \\ln \\mid \\frac{x-a}{x+a} \\mid +C\r$$ $$\\int \\frac{1}{x^2-5x}dx$$ 此类分母的二次方程常数为$0$，一次项系数不为$0$，即$\\frac{1}{x^2+bx}$型 将分母化为$x(x+b)$ 即得， $$\r\\int \\frac{1}{x^2+bx} dx = \\frac{1}{b} \\int (\\frac{1}{x}-\\frac{1}{x+b})dx = \\frac{1}{b} \\ln \\mid \\frac{x}{x+b} \\mid +C\r$$ $$\\int \\frac{1}{x^2+3x+2}dx$$此类分母的二次方程常数为$0$，一次项系数不为$0$，即$\\frac{1}{x^2+bx}$型难以将分母化为上面的形式。 需将分母化为$(x-c)^2 \\pm a^2$的形式 对于本题，不妨设 $$(x-c)^2+A = x^2+3x+2$$ 解得，\n$$\r\\begin{matrix} c=-\\frac{3}{2} \\\\A=-\\frac{1}{4}\\end{matrix}\r$$ 原式\n$$\r= \\int \\frac{1}{(x+\\frac{3}{2})^2-(\\frac{1}{2})^2}dx\r$$ 再用$3.$与$4.$的方法进一步求出积分\np=1, q\u0026gt;1的类型\r$$\\int \\frac{3x}{x^2+3x+4}dx$$ 此类分母的的一次项系数与常数项不为0，即$\\frac{ax+c}{x^2+px+q}$型，且有$p^2-4aq\u0026lt;0$。此时分母在实数范围内无法写成$(x-a)(x-b)$的形式。我们称此时分母最简。\n对于本题，不妨设$u=x^2+3x+4$,$du = 2x+3$ 分子\n$$3x=\\frac{3}{2}[(2x+3)-\\frac{9}{2}]$$$$\rI = \\frac{3}{2}(\\int \\frac{2x+3}{x^2+3x+4}dx - \\frac{9}{2} \\int \\frac{1}{x^+3x+4}dx)\r$$再用上述方法进一步求积分。\n$$\\int \\frac{3x}{x^2+3x-4}dx$$此类分母的的一次项系数与常数项不为0，即$\\frac{ax+c}{x^2+px+q}$型，且有$p^2-4aq\u0026gt;0$。此时分母在实数范围内可以写成$(x-a)(x-b)$的形式。\n将分母化为$(x+4)(x-1)$\n$$\rI = \\frac{3}{5} (\\ln |\\frac{x-1}{x+4}|) +C\r$$当然，也可以用$1.$的方法进一步求积分。\n$$\\int \\frac{3x+3}{x^2+3x+4}dx$$分子有常数项，可以用$1.$和$2.$的思路。\n到现在，形如\n$$\\int \\frac{ax+c}{x^2+px+q}dx$$ 的积分可求\np=q=2的类型\r$$\\int \\frac{3x^2+3x}{x^2+3x+4}dx$$ 分子和分母最高次均为2，可以将分母为基准进行参变分离。\n本题可化为，\n$$\r\\begin{align}\rI \u0026= \\int \\frac{3(x^2+3x+4)-6x-12}{x^2+3x+4} dx \\\\\r\u0026= 3 \\int dx - \\int \\frac{6x+12}{x^2+3x+4} dx\r\\end{align}\r$$因此，形如，\n$$\r\\int \\frac{ax^2+bx+c}{x^2+px+q}dx\r$$的积分可求。\nq\u0026gt;p\u0026gt;2的类型\r$$\\int \\frac{x^2+3x+4}{x^3+3x^2+2x}dx$$ 分子和分母最高次均大于2，可以将分母为基准因式分解。\n分母可化为, $x(x+1)(x+2)$. 原式化为，\n$$\r\\begin{split}\rI \u0026= \\int \\frac{x^2+3x+4}{x(x+1)(x+2)}dx\r\\\\\r\u0026= \\int ( \\frac{2}{x} - \\frac{2}{x+1}+ \\frac{1}{x+2})dx\r\\end{split}\r$$ $$\\int \\frac{x^2+3x+4}{x^3+3x^2+2x+1}dx$$此时不可以将分母为基准因式分解，分部积分与换元积分均失效。 无法写成初等函数的形式。\np\u0026gt;q=2的类型\r$$\\int \\frac{x^4}{x^2-3}dx$$ 此类可以用多项式的除法对分子进行分离。\n$$\r\\begin{split}\r\u0026\\underline{x^2+3} \\\\\rx^2-3)\u0026x^4 \\\\\r\u0026\\underline{x^4-3x^2} \\\\\r\u00263x^2 \\\\\r\u0026\\underline{3x^2-9} \\\\\r\u00269\r\\end{split}\r$$原式可以化为，\n$$\r\\begin{split}\rI = \\int (x^2+3) + \\frac{9}{x^2+3}dx\r\\end{split}\r$$因此，形如， $$\\int \\frac{ax^p+mx^{p-1}+\\cdots +C}{x^2+bx+c}dx$$的积分可求。\n分母低次幂积型\r约定有理真分式$\\frac{P(x)}{Q(x)}=\\frac{P(x)}{c_0(x-a)^k(x^2+px+q)^l}$,（其中$k$,$l$是正整数，$p^2-4q\u0026lt;0$） 可唯一因式分解为有限个最简有理分式之和，即 $$\r\\frac{P(x)}{Q(x)}=\\frac{A_1}{x-a}+\\frac{A_2}{(x-a)^2}+\\cdots+\\frac{A_k}{(x-a)^k} + \\frac{B_1x+D_1}{x^2+px+q}+\\frac{B_2x+D_2}{x^2+px+q}+\\cdots+\\frac{B_lx+D_l}{x^2+px+q}\r$$ 满足上面要求，则可以用待定系数法改写成上述形式。\n例题\r最后，试试下面的例子。\n$$\r\\int \\frac{3x+6}{(x-1)^2(x^2+x+1)}dx\r$$相信聪明的你一定可以求出。\n","date":"2024-12-06T20:51:30+08:00","permalink":"https://blog.ztcdream.com/p/%E6%9C%89%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%AF%E5%88%86/","title":"有理函数的积分"},{"content":"Linux系统下安装软件的方式可以通过 apt install 类似的包管理命令在线安装。\n1 apt install packagename 若软件源中没有对应软件，或者离线环境，需要从源码编译安装。\n准备工作\r下载源码包\r首先准备好要安装软件的源码\n以python3.12为例，去官网找到对应源码包的链接\nhttps://www.python.org/downloads/\n用 wget 下载到本地\n1 wget \u0026#34;https://www.python.org/ftp/python/3.12.7/Python-3.12.7.tgz\u0026#34; 解压源码包\r使用内置的tar解压\n1 2 tar -xvf Python-3.12.7.tgz cd Python-3.12.7/ 安装编译工具\r源码中有许多.c的文件，由c语言编写。因此编译前需要安装c语言库和环境。\n1 2 3 4 apt update apt install build-essential apt install make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev apt install gcc openssl 编译预配置\r源码根目录下存在一个configure文件，运行该文件，开始检查当前的运行环境，配置生成 MakeFile 文件，用于make编译。\n./configure --with-openssl=/usr/bin --prefix=/opt/python3.12.7\r这里的 \u0026ndash;prefix=/path 是指定你要安装软件的目录，可以mkdir创建。\n通常，我们都将软件安装在 /opt 下。\nconfigure的过程并不都是顺利的，要学会看报错信息，把没装的包用apt装上\n编译\r( 如果之前预编译过，先 make clean 来清除缓存 )\n首先告诉 make 配置文件MakeFile位于何处\nmake MakeFile\r执行make，开始编译\nmake\r等待编译结束\n安装\rmake install\r执行安装命令\n配置软连接\r这时cd到opt的目录，可以看到python已经安装好了。\n如果直接执行 python ，会报错 not found.\n因为linux执行某条命令，主要先访问 /bin 或 /usr/bin 等PATH是否有对应的二进制文件\n因此需要将python的二进制文件复制\n创建软连接\nln -s /opt/Python-3.12.7/bin/python3 /usr/bin\r再执行python3，可以正常启动\n","date":"2024-10-27T13:39:38+08:00","permalink":"https://blog.ztcdream.com/p/linux%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85python/","title":"Linux编译安装Python"}]